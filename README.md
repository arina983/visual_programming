# Бубенина Арина ИКС-433
# Симуляция движения объектов

Проект реализует систему моделирования движения различных объектов с использованием интерфейсов и наследования в Kotlin.

## Структура проекта

###  Файлы проекта

#### `interface.kt`
**Назначение**: Определяет интерфейс `Moviable` — контракт для всех подвижных объектов.

**Содержимое**:
- **Свойства**:
  - `x: Int` - координата X
  - `y: Int` - координата Y  
  - `current_speed: Int` - текущая скорость
- **Метод**:
  - `move(): Thread` - выполняет движение в отдельном потоке и возвращает его для управления

**Роль**: Обеспечивает полиморфизм; все классы (`Human`, `Driver`) реализуют этот интерфейс.

---

#### `class_human.kt`
**Назначение**: Базовый класс `Human` для моделирования человека, реализует `Moviable`.

**Содержимое**:
- **Свойства**:
  - `name`, `surname`, `second_name` - строки для ФИО
  - `x`, `y` - координаты
  - `current_speed` - текущая скорость (с валидацией 0–16)
  - `age` - возраст (с валидацией 0–100)
- **Конструктор**: Инициализирует свойства и выводит сообщение о создании
- **Метод** `move()`: 
  - Генерирует случайные `dx`, `dy` в пределах скорости
  - Обновляет координаты
  - Выводит информацию о движении
  - Запускается в отдельном потоке

**Роль**: Базовая модель для людей; поддерживает наследование (`open` класс).

---

#### `class_driver.kt`
**Назначение**: Производный класс `Driver : Human` для моделирования водителя (линейное движение).

**Содержимое**:
- **Конструктор**: Передаёт параметры суперклассу `Human`
- **Переопределённый метод** `move()`:
  - Движение только по оси X (`dx`)
  - Движение по оси Y отсутствует
  - Выводит "линейное" движение

**Роль**: Специализированная модель; демонстрирует переопределение метода для другого поведения.

---

#### `Main.kt`
**Назначение**: Точка входа программы — функция `main()` для запуска симуляции.

**Содержимое**:
- **Создание объектов**:
  - Массив `humans` (2 человека)
  - Массив `driver` (1 водитель)
- **Цикл симуляции**: 6 шагов (`for i in 0..5`)
  - Запуск `move()` для всех объектов
  - Сбор потоков в список
  - Ожидание завершения (`join()`)
- **Финальный вывод**: Позиции всех объектов

